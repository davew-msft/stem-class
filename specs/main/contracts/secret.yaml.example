# Kubernetes Secret for Rescan Application (EXAMPLE - DO NOT COMMIT REAL SECRETS!)
# Educational Note: Secrets store sensitive data with base64 encoding and RBAC protection
# This is an EXAMPLE file - copy to secret.yaml and add real credentials

apiVersion: v1
kind: Secret
metadata:
  name: rescan-secrets
  namespace: rescan
  labels:
    app: rescan
type: Opaque

# Use 'stringData' for plain text (auto-encoded to base64)
stringData:
  AZURE_OPENAI_API_KEY: "your-api-key-here"
  AZURE_OPENAI_ENDPOINT: "https://your-resource.cognitiveservices.azure.com/openai/"
  AZURE_OPENAI_MODEL_DEPLOYMENT: "gpt-4o"

# OR use 'data' for base64-encoded values:
# data:
#   AZURE_OPENAI_API_KEY: "eW91ci1hcGkta2V5LWhlcmU="  # base64 encoded

---
# How to create the Secret from command line (RECOMMENDED):
# 
# kubectl create secret generic rescan-secrets \
#   --from-literal=AZURE_OPENAI_API_KEY='your-api-key-here' \
#   --from-literal=AZURE_OPENAI_ENDPOINT='https://your-resource.openai.azure.com/' \
#   --from-literal=AZURE_OPENAI_MODEL_DEPLOYMENT='gpt-4o' \
#   --namespace=rescan
#
# This avoids storing secrets in files

---
# Educational Notes:
# 
# 1. NEVER commit secret.yaml with real credentials to Git
#    - Add secret.yaml to .gitignore
#    - Only commit secret.yaml.example (this file)
#
# 2. Base64 is ENCODING, not ENCRYPTION
#    - Anyone with cluster access can decode secrets
#    - Use RBAC to restrict access
#    - Consider external secret management for production (Azure Key Vault, etc.)
#
# 3. View secrets (for debugging):
#    kubectl get secret rescan-secrets -n rescan -o yaml
#    kubectl get secret rescan-secrets -n rescan -o jsonpath='{.data.AZURE_OPENAI_API_KEY}' | base64 -d
#
# 4. Update secrets:
#    kubectl edit secret rescan-secrets -n rescan
#    OR delete and recreate:
#    kubectl delete secret rescan-secrets -n rescan
#    kubectl create secret generic rescan-secrets ...
